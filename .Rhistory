rename(region = Country)
country$region <- ifelse(country$region == "United Kingdom", "UK",country$region)
country$region <- ifelse(country$region == "EIRE", "Ireland",country$region)
#Como las ventas en UK son mucho mayores que en el resto de paises aplicamos logaritmos
country <- country %>%
mutate(logVolume = log(SalesVolume),
Proportion = (SalesVolume/sum(SalesVolume))*100)
country$Proportion <- round(country$Proportion,2)
world_map <- map_data("world")
salesmap <- full_join(country, world_map, by = "region")
ggplot(salesmap, aes(map_id = region, fill = logVolume))+
geom_map(map = salesmap,  color = "white")+
expand_limits(x = salesmap$long, y = salesmap$lat)+
scale_fill_viridis_c(option = "C")
#Tabla ventas por paises y proporción
country %>%
select(region,SalesVolume,Proportion) %>%
arrange(desc(Proportion)) %>%
formattable(align = c("l", "c", "c"),
list(SalesVolume = color_bar("lightgrey"),
Proportion =
formatter("span", style = ~ style(font.weight = "bold"))),
col.names = c("País","Volumen Ventas", "Proporción"))
iinstall.packages("arules")
install.packages("arules")
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lubridate)
library(formattable)
library(mltools)
library(arules)
#Cargamos los datos:
data <- read.csv("data.csv")
class(data$InvoiceDate)
#A priori parace que solo tenemos problemas con la fecha de la factura que es leída como un string
data <- data %>%
mutate(
ParsedDate = parse_datetime(InvoiceDate, format = "%m/%d/%Y %H:%M")
)
#Comprobamos que no haya NA en el fichero
anyNA(data) #Tenemos NA
summary(data) #Solo hay NA's en CustomerID
#Borramos todos los precios y cantidades negativas
data <- data %>%
mutate(Quantity = replace(Quantity, Quantity<=0, NA),
UnitPrice = replace(UnitPrice, UnitPrice<=0, NA))
#Borramos los NA
data <- data %>%
drop_na()
#Sustituimos los NA por 0, son 135080 observaciones que pueden contener información interesante
#data$CustomerID <- ifelse(is.na(data$CustomerID)== TRUE,0,data$CustomerID)
#Si hay duplicados los eliminamos con la función de dplyr
data <- data %>%
distinct()
#Añadimos una columna con el precio total de cada venta:
data <- data %>% mutate(lineTotal = Quantity * UnitPrice)
#Añadimos una columna con el dia de la semana
data$weekDay <- wday(data$ParsedDate, label=TRUE)
#Como la etiquetas que genera automáticamente son horribles vamos a renombrarlas
levels(data$weekDay) <- c("Dom","Lun","Mar","Mie","Jue","Vie","Sab")
#Añadimos una columna con el mes del año
data$month <- month(data$ParsedDate, label = TRUE)
#Convertimos los paises en un factor
data$Country <- as.factor(data$Country)
data %>%
group_by(StockCode) %>%
summarise(count = n(),
sum_quantity = sum(Quantity),
mean_quantity = round(mean(Quantity), 2),
median_quantity = median(Quantity),
mode_quantity = unique(Quantity)[which.max(tabulate(match(Quantity, unique(Quantity))))],
sd_quantity = round(sd(Quantity), 2))
#Detalle importante a tener en cuenta: El precio de los productos son menores si se compran en grandes cantidades:
data %>%
group_by(StockCode, UnitPrice) %>%
summarise(Total = sum(Quantity)) %>% head(10)
#Observamos la cantidad total vendida de cada producto
sales <- data %>%
group_by(StockCode) %>%
summarise(Total = sum(Quantity))
#Ordenamos de mayor a menor
sales <- sales[
with(sales, order(-Total)),
]
sales %>% top_n(10) %>%
formattable(align = c("l", "c"),
list(Total = color_bar("lightgrey")),
col.names = c("Código","Nº Vendido"))
#Tenemos muchos productos que se han vendido menos de 10 veces
sum(sales$Total < 10) #En concreto 338
#Quizás lo mejor sería eliminar estos productos del Stock
sales[sales$Total < 10,]
#Total de productos vendidos, total clientes, total dinero ganado, facturas y paises
#Sumamos las columnas de cantidades y beneficio
sums <- data %>%
select(Quantity,lineTotal) %>%
summarise_all(sum)
#Cogemos los valores únicos
unic <- data %>% select(InvoiceNo, StockCode, CustomerID, Country) %>% summarise_all(n_distinct)
#Combinamos los dos dataframes
totalStats <- merge(sums,unic)
totalStats %>% formattable(align = c("c", "c", "c", "c", "c", "c"),
col.names = c("Volumen ventas","Beneficio obtenido", "Facturas emitidas","Nº de productos en Stock", "Clientes únicos", "Paises"))
data %>%
group_by(weekDay) %>%
summarise(revenue = sum(lineTotal)) %>%
ggplot(aes(x = weekDay, y = revenue)) + geom_col(fill='darkblue') + labs(x = 'Dia de la semana', y = 'Beneficio (£)', title = 'Beneficio por dia de la semana')
data %>%
group_by(month) %>%
summarise(revenue = sum(lineTotal)) %>%
ggplot(aes(x = month, y = revenue)) + geom_col(fill='darkblue') + labs(x = 'Mes', y = 'Beneficio (£)', title = 'Beneficio por mes')
#Mapa regiones vendidas
country <- data %>%
group_by(Country) %>%
summarise(SalesVolume = sum(Quantity)) %>%
rename(region = Country)
country$region <- ifelse(country$region == "United Kingdom", "UK",country$region)
country$region <- ifelse(country$region == "EIRE", "Ireland",country$region)
#Como las ventas en UK son mucho mayores que en el resto de paises aplicamos logaritmos
country <- country %>%
mutate(logVolume = log(SalesVolume),
Proportion = (SalesVolume/sum(SalesVolume))*100)
country$Proportion <- round(country$Proportion,2)
world_map <- map_data("world")
salesmap <- full_join(country, world_map, by = "region")
ggplot(salesmap, aes(map_id = region, fill = logVolume))+
geom_map(map = salesmap,  color = "white")+
expand_limits(x = salesmap$long, y = salesmap$lat)+
scale_fill_viridis_c(option = "C")
#Tabla ventas por paises y proporción
country %>%
select(region,SalesVolume,Proportion) %>%
arrange(desc(Proportion)) %>%
formattable(align = c("l", "c", "c"),
list(SalesVolume = color_bar("lightgrey"),
Proportion =
formatter("span", style = ~ style(font.weight = "bold"))),
col.names = c("País","Volumen Ventas", "Proporción"))
#Seleccionamos las columnas que nos interesan
r_data <- data %>%
select(CustomerID, Quantity, UnitPrice, Country)
onehot <- one_hot(as.data.table(r_data))
View(data)
View(data)
data %>%
select(CustomerID, StockCode)
data %>%
select(CustomerID, StockCode) %>%
group_by(CustomerID)
data %>%
select(CustomerID, StockCode) %>%
group_by(CustomerID)
data %>%
select(CustomerID, StockCode)
a_data <- data %>%
select(CustomerID, StockCode)
View(a_data)
View(a_data)
mat <- matrix(NULL)
df <- data.frame(matrix(ncol = 50, nrow = 4338))
View(df)
View(df)
a_data <- data %>%
select(CustomerID, StockCode) %>%
mutate(Products = strsplit(Products, ",")) %>%
unnest %>%
distinct(StockCode, Products) %>%
group_by(StockCode) %>%
summarise(Products = toString(Products))
a_data <- data %>%
select(CustomerID, StockCode) %>%
mutate(Products = strsplit(Products, ",")) %>%
unnest
a_data <- data %>%
select(CustomerID, StockCode) %>%
mutate(StockCode = strsplit(StockCode, ",")) %>%
unnest %>%
distinct(CustomerID, StockCode) %>%
group_by(CustomerID) %>%
summarise(StockCode = toString(StockCode))
View(a_data)
View(a_data)
?separate
a_data <- data %>%
select(CustomerID, StockCode) %>%
mutate(StockCode = strsplit(StockCode, ",")) %>%
unnest %>%
distinct(CustomerID, StockCode) %>%
group_by(CustomerID) %>%
summarise(StockCode = toString(StockCode)) %>%
separate(StockCode, sep",")
View(a_data)
View(a_data)
class(a_data$StockCode)
a_data <- data %>%
select(CustomerID, StockCode) %>%
mutate(StockCode = strsplit(StockCode, ",")) %>%
unnest %>%
distinct(CustomerID, StockCode) %>%
group_by(CustomerID) %>%
summarise(StockCode = toString(StockCode)) %>%
a_data %>% separate(col = StockCode, sep = ",", extra = "merge", into = NA)
a_data <- data %>%
select(CustomerID, StockCode) %>%
mutate(StockCode = strsplit(StockCode, ",")) %>%
unnest %>%
distinct(CustomerID, StockCode) %>%
group_by(CustomerID) %>%
summarise(StockCode = toString(StockCode)) %>%
a_data
head(a_data)
a_data %>% separate(col = StockCode, sep = ",", extra = "merge", into = NA)
a_data %>% separate(col = StockCode, sep = ",", extra = "merge")
a_data[,1]
a_data[,2]
read.table(a_data[,2],sep = ",")
a_data[,2]
Products <- a_data[,2]
View(Products)
View(Products)
View(Products)
read.table(Products, sep =",")
a_data %>% separate(StockCode, c(1:50), ",")
a_data %>% separate(StockCode, as.character(c(1:50)), ",")
a_data %>% separate(StockCode, as.character(c(1:100)), ",")
a_data %>% separate(StockCode, as.character(c(1:200)), ",")
View(a_data %>% separate(StockCode, as.character(c(1:150)), ","))
a_data %>% separate(StockCode, as.character(c(1:100)), ",")
a_data <- a_data %>% separate(StockCode, as.character(c(1:100)), ",")
View(a_data)
View(a_data)
#Convertimos en una matrix sparse para ahorrar más memoria
a_data <- read.transactions(a_data, sep = ",")
?read.transactions
#Convertimos en una matrix sparse para ahorrar más memoria
a_data <- read.transactions(a_data, sep = ",", header = TRUE)
?write.csv()
#Convertimos en una matrix sparse para ahorrar más memoria
write.csv(a_data, "DatosTransacciones.csv")
dataset <- read.transactions("DatosTransacciones.csv", header = T, sep = ",", rm.duplicates = T)
summary(dataset)
View(a_data)
View(a_data)
write.csv(a_data[,-1], "DatosTransacciones.csv")
dataset <- read.transactions("DatosTransacciones.csv", header = T, sep = ",", rm.duplicates = T)
View(dataset)
View(dataset)
summary(dataset)
info <- summary(dataset)
summary(dataset)
itemFrequencyPlot(dataset)
itemFrequencyPlot(dataset, topN = 25)
itemFrequencyPlot(dataset, topN = 50)
itemFrequencyPlot(dataset, topN = 25)
#Entrenamos el algoritmo Apriori
rules = apriori(dataset, list(support = 0.003, confidence = 0.8))
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lubridate)
library(formattable)
library(mltools)
library(arules)
#Cargamos los datos:
data <- read.csv("data.csv")
class(data$InvoiceDate)
#A priori parace que solo tenemos problemas con la fecha de la factura que es leída como un string
data <- data %>%
mutate(
ParsedDate = parse_datetime(InvoiceDate, format = "%m/%d/%Y %H:%M")
)
#Comprobamos que no haya NA en el fichero
anyNA(data) #Tenemos NA
summary(data) #Solo hay NA's en CustomerID
#Borramos todos los precios y cantidades negativas
data <- data %>%
mutate(Quantity = replace(Quantity, Quantity<=0, NA),
UnitPrice = replace(UnitPrice, UnitPrice<=0, NA))
#Borramos los NA
data <- data %>%
drop_na()
#Sustituimos los NA por 0, son 135080 observaciones que pueden contener información interesante
#data$CustomerID <- ifelse(is.na(data$CustomerID)== TRUE,0,data$CustomerID)
#Si hay duplicados los eliminamos con la función de dplyr
data <- data %>%
distinct()
#Añadimos una columna con el precio total de cada venta:
data <- data %>% mutate(lineTotal = Quantity * UnitPrice)
#Añadimos una columna con el dia de la semana
data$weekDay <- wday(data$ParsedDate, label=TRUE)
#Como la etiquetas que genera automáticamente son horribles vamos a renombrarlas
levels(data$weekDay) <- c("Dom","Lun","Mar","Mie","Jue","Vie","Sab")
#Añadimos una columna con el mes del año
data$month <- month(data$ParsedDate, label = TRUE)
#Convertimos los paises en un factor
data$Country <- as.factor(data$Country)
data %>%
group_by(StockCode) %>%
summarise(count = n(),
sum_quantity = sum(Quantity),
mean_quantity = round(mean(Quantity), 2),
median_quantity = median(Quantity),
mode_quantity = unique(Quantity)[which.max(tabulate(match(Quantity, unique(Quantity))))],
sd_quantity = round(sd(Quantity), 2))
#Detalle importante a tener en cuenta: El precio de los productos son menores si se compran en grandes cantidades:
data %>%
group_by(StockCode, UnitPrice) %>%
summarise(Total = sum(Quantity)) %>% head(10)
#Observamos la cantidad total vendida de cada producto
sales <- data %>%
group_by(StockCode) %>%
summarise(Total = sum(Quantity))
#Ordenamos de mayor a menor
sales <- sales[
with(sales, order(-Total)),
]
sales %>% top_n(10) %>%
formattable(align = c("l", "c"),
list(Total = color_bar("lightgrey")),
col.names = c("Código","Nº Vendido"))
#Tenemos muchos productos que se han vendido menos de 10 veces
sum(sales$Total < 10) #En concreto 338
#Quizás lo mejor sería eliminar estos productos del Stock
sales[sales$Total < 10,]
#Total de productos vendidos, total clientes, total dinero ganado, facturas y paises
#Sumamos las columnas de cantidades y beneficio
sums <- data %>%
select(Quantity,lineTotal) %>%
summarise_all(sum)
#Cogemos los valores únicos
unic <- data %>% select(InvoiceNo, StockCode, CustomerID, Country) %>% summarise_all(n_distinct)
#Combinamos los dos dataframes
totalStats <- merge(sums,unic)
totalStats %>% formattable(align = c("c", "c", "c", "c", "c", "c"),
col.names = c("Volumen ventas","Beneficio obtenido", "Facturas emitidas","Nº de productos en Stock", "Clientes únicos", "Paises"))
data %>%
group_by(weekDay) %>%
summarise(revenue = sum(lineTotal)) %>%
ggplot(aes(x = weekDay, y = revenue)) + geom_col(fill='darkblue') + labs(x = 'Dia de la semana', y = 'Beneficio (£)', title = 'Beneficio por dia de la semana')
data %>%
group_by(month) %>%
summarise(revenue = sum(lineTotal)) %>%
ggplot(aes(x = month, y = revenue)) + geom_col(fill='darkblue') + labs(x = 'Mes', y = 'Beneficio (£)', title = 'Beneficio por mes')
#Mapa regiones vendidas
country <- data %>%
group_by(Country) %>%
summarise(SalesVolume = sum(Quantity)) %>%
rename(region = Country)
country$region <- ifelse(country$region == "United Kingdom", "UK",country$region)
country$region <- ifelse(country$region == "EIRE", "Ireland",country$region)
#Como las ventas en UK son mucho mayores que en el resto de paises aplicamos logaritmos
country <- country %>%
mutate(logVolume = log(SalesVolume),
Proportion = (SalesVolume/sum(SalesVolume))*100)
country$Proportion <- round(country$Proportion,2)
world_map <- map_data("world")
salesmap <- full_join(country, world_map, by = "region")
ggplot(salesmap, aes(map_id = region, fill = logVolume))+
geom_map(map = salesmap,  color = "white")+
expand_limits(x = salesmap$long, y = salesmap$lat)+
scale_fill_viridis_c(option = "C")
#Tabla ventas por paises y proporción
country %>%
select(region,SalesVolume,Proportion) %>%
arrange(desc(Proportion)) %>%
formattable(align = c("l", "c", "c"),
list(SalesVolume = color_bar("lightgrey"),
Proportion =
formatter("span", style = ~ style(font.weight = "bold"))),
col.names = c("País","Volumen Ventas", "Proporción"))
# #Seleccionamos las columnas que nos interesan
# r_data <- data %>%
#   select(CustomerID, Quantity, UnitPrice, Country)
# onehot <- one_hot(as.data.table(r_data))
# pr.out <- prcomp(onehot[,-1], scale = TRUE)
# pr.out$rotation
# biplot(pr.out, scale=0)
a_data <- data %>%
select(CustomerID, StockCode) %>%
mutate(StockCode = strsplit(StockCode, ",")) %>%
unnest %>%
distinct(CustomerID, StockCode) %>%
group_by(CustomerID) %>%
summarise(StockCode = toString(StockCode)) %>%
itemFrequencyPlot(dataset, topN = 100)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lubridate)
library(formattable)
library(mltools)
library(arules)
a_data <- data %>%
select(CustomerID, StockCode) %>%
mutate(StockCode = strsplit(StockCode, ",")) %>%
unnest %>%
distinct(CustomerID, StockCode) %>%
group_by(CustomerID) %>%
summarise(StockCode = toString(StockCode)) %>%
a_data <- data %>%
select(CustomerID, StockCode) %>%
mutate(StockCode = strsplit(StockCode, ",")) %>%
unnest %>%
distinct(CustomerID, StockCode) %>%
group_by(CustomerID) %>%
summarise(StockCode = toString(StockCode))
a_data <- a_data %>% separate(StockCode, as.character(c(1:100)), ",")
#Convertimos en una matrix sparse para ahorrar más memoria
write.csv(a_data[,-1], "DatosTransacciones.csv")
dataset <- read.transactions("DatosTransacciones.csv", header = T, sep = ",", rm.duplicates = T)
summary(dataset)
itemFrequencyPlot(dataset, topN = 100)
#Entrenamos el algoritmo Apriori
rules = apriori(dataset, list(support = 0.07, confidence = 0.8))
#Entrenamos el algoritmo Apriori
rules = apriori(dataset, list(support = 0.05, confidence = 0.8))
itemFrequencyPlot(dataset, topN = 25)
inspect(sort(rules, by = "lift"))
View(data)
View(data)
class(data$StockCode)
data %>%
select(StockCode, Description) %>%
filter(StockCode == "22698", StockCode == "22699", StockCode == "22697")
data %>%
select(StockCode, Description) %>%
filter(StockCode == "22698" | StockCode == "22699"| StockCode == "22697")
data %>%
select(StockCode, Description) %>%
filter(StockCode == "22698" | StockCode == "22699"| StockCode == "22697") %>%
unique()
#Volvemos a aplicar las reglas de asociación pero con una confianza un poco más baja
rules = apriori(dataset, list(support = 0.05, confidence = 0.6))
inspect(sort(rules, by = "lift"))
inspect(sort(rules, by = "lift")[1:10])
data %>%
select(StockCode, Description) %>%
filter(StockCode == "22698" | StockCode == "22699"| StockCode == "22697" | StockCode == "22910" | StockCode == "22086") %>%
unique()
library(arulesViz)
install.packages("arulesViz")
library(arulesViz)
plot(rules, method = "graph", engine = "htmlwidget")
plot(rules[1:10], method = "graph", engine = "htmlwidget")
reglas <- sort(rules, by = "lift")[1:10]
plot(reglas, method = "graph", engine = "htmlwidget")
View(data)
View(data)
rl_data <- data %>%
select(lineTotal, Quantity, UnitPrice)
View(rl_data)
View(rl_data)
?lm
rl_data <- data %>%
select(lineTotal, Quantity, UnitPrice)
fit1 <- lm(lineTotal ~., data = rl_data)
fit1 #El coeficiente tiene el signo esperado (Positivo)
summary(fit1)
fit1$coefficients
plot(fit1)
confint(fit1, level = 0.9)[,2]
confint(fit1, level = 0.9)[,2]
confint(fit1, level = 0.9)
?corr
?confint
confint(fit1, "UnitPrice", level = 0.9)
confint(fit1, level = 0.9)
confint(fit1, level = 0.9)
rl_data <- data %>%
select(lineTotal, Quantity, UnitPrice)
fit1 <- lm(lineTotal ~., data = rl_data)
fit1 #El coeficiente tiene el signo esperado (Positivo)
summary(fit1)
corr()
plot(Quantity,Price)
?plot
plot(data = rl_data,Quantity,Price)
plot(rl_data$Quantity,rl_data$Price)
plot(rl_data$Quantity,rl_data$lineTotal)
abline(fit1)
equation1=function(x){coef(fit1)[2]*x+coef(fit1)[1]}
equation2=function(x){coef(fit1)[2]*x+coef(fit1)[1]+coef(fit1)[3]}
ggplot(radial,aes(y=NTAV,x=age,color=sex))+geom_point()+
stat_function(fun=equation1,geom="line",color=scales::hue_pal()(2)[1])+
stat_function(fun=equation2,geom="line",color=scales::hue_pal()(2)[2])
equation1=function(x){coef(fit1)[2]*x+coef(fit1)[1]}
equation2=function(x){coef(fit1)[2]*x+coef(fit1)[1]+coef(fit1)[3]}
ggplot(rl_data,aes(y=NTAV,x=age,color=sex))+geom_point()+
stat_function(fun=equation1,geom="line",color=scales::hue_pal()(2)[1])+
stat_function(fun=equation2,geom="line",color=scales::hue_pal()(2)[2])
equation1=function(x){coef(fit1)[2]*x+coef(fit1)[1]}
equation2=function(x){coef(fit1)[2]*x+coef(fit1)[1]+coef(fit1)[3]}
ggplot(rl_data,aes(y=lineTotal,x=Quantity,color=UnitPrice))+geom_point()+
stat_function(fun=equation1,geom="line",color=scales::hue_pal()(2)[1])+
stat_function(fun=equation2,geom="line",color=scales::hue_pal()(2)[2])
fit1 <- lm(lineTotal ~ Quantity, data = rl_data)
abline(fit1)
fit1 <- lm(lineTotal ~ Quantity, data = rl_data)
abline(fit1)
plot(rl_data$Quantity,rl_data$lineTotal)
abline(fit1)
ggplotRegression(lm(lineTotal ~ Quantity, data = rl_data))
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lubridate)
library(formattable)
library(mltools)
library(arules)
library(arulesViz)
library(ggplot2)
ggplotRegression(lm(lineTotal ~ Quantity, data = rl_data))
fit1 <- lm(lineTotal ~ Quantity, data = rl_data)
plot(lineTotal ~ Quantity, data = rl_data)
abline(fit1)
